# This code loads and analyzes the results of the PRM sampler comparison
# from the prm_vs_samplers.py script. It calculates the average path length
# and standard deviation for each sampler and plots the paths generated by
# each sampler. The results are printed to the console.
import argparse
import numpy as np
import matplotlib.pyplot as plt
import pickle
import pandas

from config import SAMPLERS

parser = argparse.ArgumentParser()
parser.add_argument('--nodes', type=int, default=100, help='Number of nodes in PRM roadmap')
parser.add_argument('--level', type=int, default=1, help='Difficulty level of the environment')
parser.add_argument('--reps', type=int, default=10, help='Number of repetitions for each sampler')
# if the plot flag is entered in the command line, the results will be plotted
parser.add_argument('--plot', action='store_true', help='Plot the results')
args = parser.parse_args()

def analyse(nodes, reps, plot=True):
    # Load results from file
    file = "results/results_" + str(nodes) + "_" + str(reps) + "_" + str(args.level) + ".npy"
    print(f'Loading results from {file}')
    try:
        results = np.load(file, allow_pickle=True).item()
    except:
        print('Results file not found. Please run the PRM sampler comparison script first.')
        return

    # Print results and save them to a csv file
    # each line will correspond to a distribution and each column to a metric
    res = {}

    # header specifying the number of nodes
    print(f'\n Analyzing results for {nodes} nodes and {reps} reps')
    for distribution, data in results.items():
        if distribution in ['mpmc_batch', 'mpmc_l2bat']:
            reps = results[distribution]['batch_size'][0]
        elif distribution in ["mpmc", "mpmc_seq", "sobol_unscr", "halton_unscr"]:
            reps = 1 
        else:
            reps = args.reps


        print(f'Sampler: {distribution}')
        res[distribution] = {}
        print(f'  Cardinality: {np.mean(data["cardinality"])}')
        res[distribution]['average_cardinality'] = np.mean(data["cardinality"])
        print(f'  Std Dev Cardinality: {np.std(data["cardinality"])}')
        res[distribution]['std_dev_cardinality'] = np.std(data["cardinality"])
        print(f'  Average Path Length: {np.mean(data["lengths"])}')
        res[distribution]['average_path_length'] = np.mean(data["lengths"])
        print(f'  Std Dev Path Length: {np.std(data["lengths"])}')
        res[distribution]['std_dev_path_length'] = np.std(data["lengths"])
        gain = (np.mean(results['uniform']['lengths']) - np.mean(data['lengths'])) / np.mean(results['uniform']['lengths']) * 100
        print(f'  Gain against Uniform: {gain:.2f}%')
        res[distribution]['percentage_gain'] = gain


        misses = reps - len(data['lengths'])
        print(f'  Misses: {misses}')
        # miss percentage
        res[distribution]['miss_percentage'] = misses / (reps) * 100
        print(f'  Miss Percentage: {misses / (reps) * 100:.2f}%')
        print(f'reps: {reps}')

        res[distribution]['misses'] = misses

    # save results to csv file
    df = pandas.DataFrame(res)
    # if some samplers are missing, add them with NaN values
    for sampler in SAMPLERS:
        if sampler not in df.columns:
            df[sampler] = np.nan

    # rearrange columns to match the order above
    df = df[SAMPLERS]
    
    df.to_csv('results/analysis/summary_' + str(nodes) + "_" + str(args.level) + '.csv')


    if plot:
        # # make box plot of path lengths for each sampler from values printed above
        # plt.figure()
        # plt.boxplot([data['lengths'] for data in results.values()], tick_labels=results.keys())
        # plt.ylabel('Path Length')
        # plt.title('Path Lengths for Different Samplers')
        # name = 'results/analysis/path_lengths_' + str(nodes) + "_" + str(reps) + "_" + str(args.level) + '.png'
        # plt.savefig(name)
        
        # Plotting results
        plt.figure()
        # make it 4x4 subplots
        plt.subplot(4, 4, 1)
        plot_id = {dist: i+1 for i, dist in enumerate(SAMPLERS)}
        alphas = {dist: 0.5 for dist in SAMPLERS}
        alphas['mpmc'] = 1
        alphas['mpmc_seq'] = 1

        for distribution, data in results.items():
            plt.subplot(4, 4, plot_id[distribution])
            # use the map png file as the background
            img = plt.imread('results/maps/map_level_' + str(args.level) + '.png')
            # flip the image vertically
            img = np.flipud(img)
            # make sure the size of the plot is the same as the map 640, 480
            plt.imshow(img, extent=[0, 640, 0, 480])

            for path_coordinates in data['paths']:
                xs, ys = zip(*path_coordinates)
                plt.plot(xs, ys, color='olive', label=f'{distribution} path', alpha=alphas[distribution])
                # plot the start and goal positions with big red and green dots
                plt.plot(xs[0], ys[0], 'go', label='Start', ms=4)
                plt.plot(xs[-1], ys[-1], 'ro', label='Goal', ms=4)

            plt.title(f'{distribution}')
            # remove ticks
            plt.xticks([])
            plt.yticks([])
            # flip the y axis
            plt.gca().invert_yaxis()

        plt.tight_layout()
        name = 'results/analysis/paths_' + str(nodes) + "_" + str(reps) + "_" + str(args.level) + '.png'
        plt.savefig(name)

if __name__ == '__main__':
    analyse(args.nodes, args.reps, args.plot)