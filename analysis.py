# This code loads and analyzes the results of the PRM sampler comparison
# from the prm_vs_samplers.py script. It calculates the average path length
# and standard deviation for each sampler and plots the paths generated by
# each sampler. The results are printed to the console.
import argparse
import numpy as np
import matplotlib.pyplot as plt
import pickle
import pandas

parser = argparse.ArgumentParser()
parser.add_argument('--nodes', type=int, default=100, help='Number of nodes in PRM roadmap')
parser.add_argument('--iterations', type=int, default=10, help='Number of iterations to run')
parser.add_argument('--level', type=int, default=1, help='Difficulty level of the environment')
parser.add_argument('--plot', type=bool, default=True, help='Plot the results')
args = parser.parse_args()

def analyse(nodes, iterations, plot=True):
    # Load results from file
    file = "results/results_" + str(nodes) + "_" + str(iterations) + "_" + str(args.level) + ".npy"
    try:
        results = np.load(file, allow_pickle=True).item()
    except:
        print('Results file not found. Please run the PRM sampler comparison script first.')
        return


    # Print results and save them to a csv file
    # each line will correspond to a distribution and each column to a metric
    res = {}

    # header specifying the number of nodes and iterations
    print(f'Analyzing results for {nodes} nodes and {iterations} iterations')
    for distribution, data in results.items():
        reps = 10 if distribution in ["uniform", "sobol_scram", "halton_scram", "tri_lat", "sukharev"] else 1

        print(f'Sampler: {distribution}')
        res[distribution] = {}
        print(f'  Cardinality: {np.mean(data["cardinality"])}')
        res[distribution]['average_cardinality'] = np.mean(data["cardinality"])
        print(f'  Std Dev Cardinality: {np.std(data["cardinality"])}')
        res[distribution]['std_dev_cardinality'] = np.std(data["cardinality"])
        print(f'  Average Path Length: {np.mean(data["lengths"])}')
        res[distribution]['average_path_length'] = np.mean(data["lengths"])
        print(f'  Std Dev Path Length: {np.std(data["lengths"])}')
        res[distribution]['std_dev_path_length'] = np.std(data["lengths"])
        gain = (np.mean(results['uniform']['lengths']) - np.mean(data['lengths'])) / np.mean(results['uniform']['lengths']) * 100
        print(f'  Gain against Uniform: {gain:.2f}%')
        res[distribution]['percentage_gain'] = gain

        misses = reps*iterations - len(data['lengths'])
        print(f'  Misses: {misses}')

        res[distribution]['misses'] = misses

    # save results to csv file
    df = pandas.DataFrame(res)
    # rearrange columns to match the order above
    df = df[['sobol_scram', 'sobol_unscr', 'uniform', 'mpmc', 'halton_unscr', 'halton_scram', 'tri_lat', 'sukharev']]
    df.to_csv('results/analysis/summary_' + str(nodes) + "_" + str(iterations) + "_" + str(args.level) + '.csv')


    if plot:
        # make box plot of path lengths for each sampler from values printed above
        plt.figure()
        plt.boxplot([data['lengths'] for data in results.values()], tick_labels=results.keys())
        plt.ylabel('Path Length')
        plt.title('Path Lengths for Different Samplers')
        name = 'results/analysis/path_lengths_' + str(args.nodes) + "_" + str(args.iterations) + "_" + str(args.level) + '.png'
        plt.savefig(name)
        
        # Plotting results
        plt.figure()
        # make it 2x2 subplots
        plt.subplot(2, 4, 1)
        colors = {'sobol_scram': 'b', 'sobol_unscr': 'c', 'uniform': 'm', 'mpmc': 'g', 'halton_scram': 'r', 'halton_unscr': 'y', 'tri_lat': 'k', 'sukharev': 'orange'}
        plot_id = {'sobol_scram': 1, 'sobol_unscr': 2, 'uniform': 3, 'mpmc': 4, 'halton_scram': 5, 'halton_unscr': 6, 'tri_lat': 7, 'sukharev': 8}
        alphas = {'sobol_scram': 0.1, 'sobol_unscr': 0.7, 'uniform': 0.1, 'mpmc': 0.7, 'halton_scram': 0.1, 'halton_unscr': 0.7, 'tri_lat': 0.1, 'sukharev': 0.1}

        for distribution, data in results.items():
            plt.subplot(2, 4, plot_id[distribution])
            # use the map png file as the background
            img = plt.imread('results/maps/map_level_' + str(args.level) + '.png')
            # flip the image vertically
            img = np.flipud(img)
            # make sure the size of the plot is the same as the map 640, 480
            plt.imshow(img, extent=[0, 640, 0, 480])

            for path_coordinates in data['paths']:
                xs, ys = zip(*path_coordinates)
                plt.plot(xs, ys, color=colors[distribution], label=f'{distribution} path', alpha=alphas[distribution])
                # plot the start and goal positions with big red and green dots
                plt.plot(xs[0], ys[0], 'ro', label='Start', ms=2)
                plt.plot(xs[-1], ys[-1], 'o', label='Goal', ms=2, color='orange')

            plt.title(f'{distribution}')
            # remove ticks
            plt.xticks([])
            plt.yticks([])
            # flip the y axis
            plt.gca().invert_yaxis()

        plt.tight_layout()
        name = 'results/analysis/paths_' + str(args.nodes) + "_" + str(args.iterations) + "_" + str(args.level) + '.png'
        plt.savefig(name)

if __name__ == '__main__':
    analyse(args.nodes, args.iterations, args.plot)