# This code loads and analyzes the results of the PRM sampler comparison
# from the prm_vs_samplers.py script. It calculates the average path length
# and standard deviation for each sampler and plots the paths generated by
# each sampler. The results are printed to the console.
import argparse
import numpy as np
import matplotlib.pyplot as plt
import pickle
import pandas

parser = argparse.ArgumentParser()
parser.add_argument('--nodes', type=int, default=100, help='Number of nodes in PRM roadmap')
parser.add_argument('--iterations', type=int, default=10, help='Number of iterations to run')
parser.add_argument('--plot', type=bool, default=True, help='Plot the results')
args = parser.parse_args()

def analyse(nodes, iterations, plot=True):
    # Load results from file
    file = "results/results_" + str(nodes) + "_" + str(iterations) + ".npy"
    # np load pickle true
    try:
        results = np.load(file, allow_pickle=True).item()
    except:
        print('Results file not found. Please run the PRM sampler comparison script first.')
        return


    # Print results and save them to a csv file
    # each line will correspond to a distribution and each column to a metric
    res = {}

    # header specifying the number of nodes and iterations
    print(f'Analyzing results for {nodes} nodes and {iterations} iterations')
    for distribution, data in results.items():
        print(f'Sampler: {distribution}')
        res[distribution] = {}
        print(f'  Cardinality: {np.mean(data["cardinality"])}')
        res[distribution]['average_cardinality'] = np.mean(data["cardinality"])
        print(f'  Std Dev Cardinality: {np.std(data["cardinality"])}')
        res[distribution]['std_dev_cardinality'] = np.std(data["cardinality"])
        print(f'  Average Path Length: {np.mean(data["lengths"])}')
        res[distribution]['average_path_length'] = np.mean(data["lengths"])
        print(f'  Std Dev Path Length: {np.std(data["lengths"])}')
        res[distribution]['std_dev_path_length'] = np.std(data["lengths"])
        gain = (np.mean(results['uniform']['lengths']) - np.mean(data['lengths'])) / np.mean(results['uniform']['lengths']) * 100
        print(f'  Gain against Uniform: {gain:.2f}%')
        res[distribution]['percentage_gain'] = gain

    # save results to csv file
    df = pandas.DataFrame(res)
    df.to_csv('results/results_' + str(nodes) + "_" + str(iterations) + '.csv')


    if plot:
        # make box plot of path lengths for each sampler from values printed above
        plt.figure()
        plt.boxplot([data['lengths'] for data in results.values()], tick_labels=results.keys())
        plt.ylabel('Path Length')
        plt.title('Path Lengths for Different Samplers')
        name = 'results/path_lengths_' + str(args.nodes) + "_" + str(args.iterations) + '.png'
        plt.savefig(name)
        
        # Plotting results
        plt.figure()
        # make it 2x2 subplots
        plt.subplot(2, 2, 1)
        colors = {'sobol_scram': 'b', 'sobol_unscr': 'c', 'uniform': 'm', 'mpmc': 'g'}
        plot_id = {'sobol_scram': 1, 'sobol_unscr': 2, 'uniform': 3, 'mpmc': 4}
        alphas = {'sobol_scram': 0.1, 'sobol_unscr': 1, 'uniform': 0.1, 'mpmc': 1}

        for distribution, data in results.items():
            plt.subplot(2, 2, plot_id[distribution])
            for path_coordinates in data['paths']:
                xs, ys = zip(*path_coordinates)
                plt.plot(xs, ys, color=colors[distribution], label=f'{distribution} path', alpha=alphas[distribution])
                # plot the start and goal positions with big red and green dots
                plt.plot(xs[0], ys[0], 'ro', label='Start', ms=2)
                plt.plot(xs[-1], ys[-1], 'o', label='Goal', ms=2, color='orange')

            plt.title(f'{distribution}')
            plt.gca().invert_yaxis()
            # remove ticks
            plt.xticks([])
            plt.yticks([])

        plt.tight_layout()
        name = 'results/all_paths_' + str(args.nodes) + "_" + str(args.iterations) + '.png'
        plt.savefig(name)

if __name__ == '__main__':
    analyse(args.nodes, args.iterations, args.plot)